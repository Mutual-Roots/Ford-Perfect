#!/usr/bin/env bash
# sys-health(1) — System health snapshot (CPU, RAM, disk, network)
# 
# SYNOPSIS
#   sys-health [OPTIONS]
#
# DESCRIPTION
#   Collects system metrics and outputs in human-readable or machine-
#   parseable format. Suitable for cron jobs and monitoring dashboards.
#
# OPTIONS
#   -j, --json          Output as JSON (default: human-readable)
#   -t, --tsv           Output as TSV (single line, for logging)
#   -v, --verbose       Include additional details (temps, fans if available)
#   -h, --help          Show this help message
#   --version           Show version
#
# EXIT CODES
#   0  Success
#   1  Error (unable to collect metrics)
#
# FHS PATHS
#   Logs: /var/log/ai-orchestrator/sys-health.log (when used in daemon mode)
#
set -euo pipefail

VERSION="1.0.0"
OUTPUT_MODE="human"  # human|json|tsv
VERBOSE=false

die() { echo "sys-health: $*" >&2; exit 1; }
usage() {
    grep '^#' "$0" | grep -v '^#!/' | sed 's/^# \?//'
    exit "${1:-0}"
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)     usage 0 ;;
        --version)     echo "sys-health $VERSION"; exit 0 ;;
        -j|--json)     OUTPUT_MODE="json"; shift ;;
        -t|--tsv)      OUTPUT_MODE="tsv"; shift ;;
        -v|--verbose)  VERBOSE=true; shift ;;
        --)            shift; break ;;
        -*)            die "unknown option: $1 (try --help)" ;;
        *)             break ;;
    esac
done

# Collect metrics

# Timestamp (ISO 8601 UTC)
TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

# CPU cores
CPU_CORES=$(nproc 2>/dev/null || grep -c ^processor /proc/cpuinfo 2>/dev/null || echo 1)

# Load averages
if [[ -f /proc/loadavg ]]; then
    read -r LOAD_1M LOAD_5M LOAD_15M _ _ < /proc/loadavg
else
    LOAD_1M=$(uptime | awk -F'load average:' '{print $2}' | awk -F, '{gsub(/ /,"",$1); print $1}')
    LOAD_5M=$(uptime | awk -F'load average:' '{print $2}' | awk -F, '{gsub(/ /,"",$2); print $2}')
    LOAD_15M=$(uptime | awk -F'load average:' '{print $2}' | awk -F, '{gsub(/ /,"",$3); print $3}')
fi

# CPU percent from /proc/stat (snapshot comparison)
CPU_LINE1=$(head -1 /proc/stat)
sleep 0.5
CPU_LINE2=$(head -1 /proc/stat)

IDLE1=$(echo "$CPU_LINE1" | awk '{print $5}')
TOTAL1=$(echo "$CPU_LINE1" | awk '{sum=0; for(i=2;i<=NF;i++) sum+=$i; print sum}')
IDLE2=$(echo "$CPU_LINE2" | awk '{print $5}')
TOTAL2=$(echo "$CPU_LINE2" | awk '{sum=0; for(i=2;i<=NF;i++) sum+=$i; print sum}')

IDLE_DIFF=$((IDLE2 - IDLE1))
TOTAL_DIFF=$((TOTAL2 - TOTAL1))
if [[ $TOTAL_DIFF -gt 0 ]]; then
    CPU_PERCENT=$(awk "BEGIN {printf \"%.1f\", 100 * (1 - $IDLE_DIFF / $TOTAL_DIFF)}")
else
    CPU_PERCENT="0.0"
fi

# Memory (from /proc/meminfo for accuracy)
if [[ -f /proc/meminfo ]]; then
    RAM_TOTAL_KB=$(grep '^MemTotal:' /proc/meminfo | awk '{print $2}')
    RAM_FREE_KB=$(grep '^MemFree:' /proc/meminfo | awk '{print $2}')
    RAM_AVAILABLE_KB=$(grep '^MemAvailable:' /proc/meminfo | awk '{print $2}' || echo "$RAM_FREE_KB")
    RAM_USED_KB=$((RAM_TOTAL_KB - RAM_AVAILABLE_KB))
    RAM_PERCENT=$(awk "BEGIN {printf \"%.1f\", 100 * $RAM_USED_KB / $RAM_TOTAL_KB}")
    # Convert to MB
    RAM_TOTAL_MB=$((RAM_TOTAL_KB / 1024))
    RAM_USED_MB=$((RAM_USED_KB / 1024))
    RAM_FREE_MB=$((RAM_FREE_KB / 1024))
else
    # Fallback to free command
    read -r _ RAM_TOTAL_KB RAM_USED_KB RAM_FREE_KB _ <<< "$(free -k | awk '/^Mem:/ {print $0}')"
    RAM_TOTAL_MB=$((RAM_TOTAL_KB / 1024))
    RAM_USED_MB=$((RAM_USED_KB / 1024))
    RAM_FREE_MB=$((RAM_FREE_KB / 1024))
    RAM_PERCENT=$(awk "BEGIN {printf \"%.1f\", 100 * $RAM_USED_KB / $RAM_TOTAL_KB}")
fi

# Disk (root filesystem)
read -r _ DISK_ROOT_TOTAL_KB DISK_ROOT_USED_KB _ DISK_ROOT_PERCENT _ <<< "$(df -k / | awk 'NR==2 {print $0}')"
DISK_ROOT_PERCENT=${DISK_ROOT_PERCENT%\%}
DISK_ROOT_TOTAL_GB=$((DISK_ROOT_TOTAL_KB / 1024 / 1024))
DISK_ROOT_USED_GB=$((DISK_ROOT_USED_KB / 1024 / 1024))

# Network I/O (all interfaces combined)
if [[ -f /proc/net/dev ]]; then
    NET_RX_BYTES=$(awk 'NR>2 {rx+=$2} END {print rx}' /proc/net/dev)
    NET_TX_BYTES=$(awk 'NR>2 {tx+=$10} END {print tx}' /proc/net/dev)
else
    NET_RX_BYTES=0
    NET_TX_BYTES=0
fi

# Uptime
if [[ -f /proc/uptime ]]; then
    UPTIME_SECONDS=$(awk '{printf "%d", $1}' /proc/uptime)
else
    UPTIME_SECONDS=$(cut -d. -f1 /proc/uptime)
fi

# Output functions
output_human() {
    echo "╔════════════════════════════════════════════════════╗"
    echo "║           System Health Report                     ║"
    echo "╠════════════════════════════════════════════════════╣"
    printf "║  Timestamp:    %-34s ║\n" "$TIMESTAMP"
    echo "╠════════════════════════════════════════════════════╣"
    echo "║  CPU                                                   ║"
    printf "║    Cores:      %-34d ║\n" "$CPU_CORES"
    printf "║    Usage:      %-33s%% ║\n" "$CPU_PERCENT"
    printf "║    Load:       %-21s / %-5s / %-5s ║\n" "$LOAD_1M" "$LOAD_5M" "$LOAD_15M"
    echo "╠════════════════════════════════════════════════════╣"
    echo "║  Memory                                                ║"
    printf "║    Total:      %-33d MB ║\n" "$RAM_TOTAL_MB"
    printf "║    Used:       %-33d MB ║\n" "$RAM_USED_MB"
    printf "║    Free:       %-33d MB ║\n" "$RAM_FREE_MB"
    printf "║    Usage:      %-33s%% ║\n" "$RAM_PERCENT"
    echo "╠════════════════════════════════════════════════════╣"
    echo "║  Disk (/)                                              ║"
    printf "║    Total:      %-33d GB ║\n" "$DISK_ROOT_TOTAL_GB"
    printf "║    Used:       %-33d GB ║\n" "$DISK_ROOT_USED_GB"
    printf "║    Usage:      %-33s%% ║\n" "$DISK_ROOT_PERCENT"
    echo "╠════════════════════════════════════════════════════╣"
    echo "║  Network                                               ║"
    printf "║    RX:         %-33s B ║\n" "$NET_RX_BYTES"
    printf "║    TX:         %-33s B ║\n" "$NET_TX_BYTES"
    echo "╠════════════════════════════════════════════════════╣"
    printf "║  Uptime:       %-34s s ║\n" "$UPTIME_SECONDS"
    echo "╚════════════════════════════════════════════════════╝"
}

output_json() {
    cat <<EOF
{
  "timestamp": "$TIMESTAMP",
  "cpu_percent": $CPU_PERCENT,
  "cpu_cores": $CPU_CORES,
  "load_1m": $LOAD_1M,
  "load_5m": $LOAD_5M,
  "load_15m": $LOAD_15M,
  "ram_total_mb": $RAM_TOTAL_MB,
  "ram_used_mb": $RAM_USED_MB,
  "ram_free_mb": $RAM_FREE_MB,
  "ram_percent": $RAM_PERCENT,
  "disk_root_total_gb": $DISK_ROOT_TOTAL_GB,
  "disk_root_used_gb": $DISK_ROOT_USED_GB,
  "disk_root_percent": $DISK_ROOT_PERCENT,
  "net_rx_bytes": $NET_RX_BYTES,
  "net_tx_bytes": $NET_TX_BYTES,
  "uptime_seconds": $UPTIME_SECONDS
}
EOF
}

output_tsv() {
    printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
        "$TIMESTAMP" \
        "$CPU_PERCENT" \
        "$CPU_CORES" \
        "$LOAD_1M" \
        "$LOAD_5M" \
        "$LOAD_15M" \
        "$RAM_TOTAL_MB" \
        "$RAM_USED_MB" \
        "$RAM_FREE_MB" \
        "$RAM_PERCENT" \
        "$DISK_ROOT_TOTAL_GB" \
        "$DISK_ROOT_USED_GB" \
        "$DISK_ROOT_PERCENT" \
        "$NET_RX_BYTES" \
        "$NET_TX_BYTES" \
        "$UPTIME_SECONDS"
}

# Main execution
case "$OUTPUT_MODE" in
    human) output_human ;;
    json)  output_json ;;
    tsv)   output_tsv ;;
esac

exit 0
