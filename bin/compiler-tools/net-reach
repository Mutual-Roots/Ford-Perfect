#!/usr/bin/env bash
# net-reach(1) — Network reachability and latency testing
#
# SYNOPSIS
#   net-reach [OPTIONS] TARGET...
#
# DESCRIPTION
#   Tests connectivity to network targets via ICMP, TCP, or HTTP.
#   Reports latency, packet loss, and service availability.
#
# OPTIONS
#   -p, --port PORT       Test TCP connectivity to PORT
#   -u, --url URL         Test HTTP/HTTPS endpoint (implies --port 80/443)
#   -m, --method METHOD   HTTP method (GET|HEAD|POST, default: HEAD)
#   -c, --count N         Number of probes (default: 3)
#   -t, --timeout SEC     Timeout per probe (default: 5)
#   -j, --json            Output as JSON
#   -T, --tsv             Output as TSV
#   --expect-code CODE    Expected HTTP status code (default: 200)
#   --expect-body RE      Regex pattern expected in response body
#   -q, --quiet           Suppress non-error output
#   -h, --help            Show this help message
#   --version             Show version
#
# EXIT CODES
#   0  All targets reachable
#   1  One or more targets unreachable
#   2  Invalid arguments or configuration error
#
set -euo pipefail

VERSION="1.0.0"
OUTPUT_MODE="human"  # human|json|tsv
PORT=""
URL=""
HTTP_METHOD="HEAD"
PROBE_COUNT=3
TIMEOUT=5
EXPECT_CODE=200
EXPECT_BODY=""
QUIET=false
declare -a TARGETS=()

die() { echo "net-reach: $*" >&2; exit 2; }
usage() {
    grep '^#' "$0" | grep -v '^#!/' | sed 's/^# \?//'
    exit "${1:-0}"
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)        usage 0 ;;
        --version)        echo "net-reach $VERSION"; exit 0 ;;
        -j|--json)        OUTPUT_MODE="json"; shift ;;
        -T|--tsv)         OUTPUT_MODE="tsv"; shift ;;
        -p|--port)        PORT="${2:?--port requires a port number}"; shift 2 ;;
        -u|--url)         URL="${2:?--url requires a URL}"; shift 2 ;;
        -m|--method)      HTTP_METHOD="${2:?--method requires GET|HEAD|POST}"; shift 2 ;;
        -c|--count)       PROBE_COUNT="${2:?--count requires a number}"; shift 2 ;;
        -t|--timeout)     TIMEOUT="${2:?--timeout requires seconds}"; shift 2 ;;
        --expect-code)    EXPECT_CODE="${2:?--expect-code requires HTTP code}"; shift 2 ;;
        --expect-body)    EXPECT_BODY="${2:?--expect-body requires regex}"; shift 2 ;;
        -q|--quiet)       QUIET=true; shift ;;
        --)               shift; TARGETS+=("$@"); break ;;
        -*)               die "unknown option: $1 (try --help)" ;;
        *)                TARGETS+=("$1"); shift ;;
    esac
done

if [[ ${#TARGETS[@]} -eq 0 && -z "$URL" ]]; then
    die "no target specified. Provide hostname(s) or use --url"
fi

# Add URL as target if specified
if [[ -n "$URL" ]]; then
    TARGETS+=("$URL")
fi

# Validate HTTP method
case "$HTTP_METHOD" in
    GET|HEAD|POST|PUT|DELETE|PATCH) ;;
    *) die "invalid HTTP method: $HTTP_METHOD (use GET|HEAD|POST|PUT|DELETE|PATCH)" ;;
esac

# Test ICMP ping
test_icmp() {
    local target="$1"
    local latencies=()
    local success=0
    
    for ((i=0; i<PROBE_COUNT; i++)); do
        local result time_ms
        result=$(ping -c 1 -W "$TIMEOUT" "$target" 2>&1) || true
        
        if [[ "$result" == *"time="* ]]; then
            time_ms=$(echo "$result" | grep -oP 'time=\K[0-9.]+' || echo "")
            if [[ -n "$time_ms" ]]; then
                latencies+=("$time_ms")
                ((success++)) || true
            fi
        fi
    done
    
    # Calculate stats
    local failed=$((PROBE_COUNT - success))
    local reachable="false" avg_ms="0" min_ms="0" max_ms="0" packet_loss="100"
    
    if [[ $success -gt 0 ]]; then
        reachable="true"
        packet_loss=$(awk "BEGIN {printf \"%.0f\", 100 * $failed / $PROBE_COUNT}")
        
        # Sort latencies for min/max
        IFS=$'\n' sorted=($(sort -g <<<"${latencies[*]}")); unset IFS
        min_ms="${sorted[0]}"
        max_ms="${sorted[-1]}"
        
        # Calculate average
        local sum=0
        for lat in "${latencies[@]}"; do
            sum=$(awk "BEGIN {print $sum + $lat}")
        done
        avg_ms=$(awk "BEGIN {printf \"%.1f\", $sum / $success}")
    fi
    
    echo "$reachable|$avg_ms|$min_ms|$max_ms|$packet_loss||"
}

# Test TCP port connectivity
test_tcp() {
    local target="$1"
    local port="$2"
    local latencies=()
    local success=0
    
    for ((i=0; i<PROBE_COUNT; i++)); do
        local start_ms end_ms
        start_ms=$(date +%s%3N)
        
        if timeout "$TIMEOUT" bash -c "echo >/dev/tcp/$target/$port" 2>/dev/null; then
            end_ms=$(date +%s%3N)
            local elapsed=$((end_ms - start_ms))
            latencies+=("$elapsed")
            ((success++)) || true
        fi
    done
    
    # Calculate stats
    local failed=$((PROBE_COUNT - success))
    local reachable="false" avg_ms="0" min_ms="0" max_ms="0" packet_loss="100"
    
    if [[ $success -gt 0 ]]; then
        reachable="true"
        packet_loss=$(awk "BEGIN {printf \"%.0f\", 100 * $failed / $PROBE_COUNT}")
        
        IFS=$'\n' sorted=($(sort -n <<<"${latencies[*]}")); unset IFS
        min_ms="${sorted[0]}"
        max_ms="${sorted[-1]}"
        
        local sum=0
        for lat in "${latencies[@]}"; do
            sum=$((sum + lat))
        done
        avg_ms=$(awk "BEGIN {printf \"%.1f\", $sum / $success}")
    fi
    
    echo "$reachable|$avg_ms|$min_ms|$max_ms|$packet_loss||"
}

# Test HTTP endpoint
test_http() {
    local url="$1"
    local latencies=()
    local codes=()
    local success=0
    
    for ((i=0; i<PROBE_COUNT; i++)); do
        local start_ms end_ms http_code
        start_ms=$(date +%s%3N)
        
        http_code=$(curl -so /dev/null -w "%{http_code}" \
            -X "$HTTP_METHOD" \
            --connect-timeout "$TIMEOUT" \
            --max-time "$((TIMEOUT * 2))" \
            "$url" 2>/dev/null) || http_code="000"
        
        end_ms=$(date +%s%3N)
        local elapsed=$((end_ms - start_ms))
        
        if [[ "$http_code" =~ ^[23] ]]; then
            latencies+=("$elapsed")
            codes+=("$http_code")
            ((success++)) || true
        fi
    done
    
    # Calculate stats
    local failed=$((PROBE_COUNT - success))
    local reachable="false" avg_ms="0" min_ms="0" max_ms="0" packet_loss="100"
    local last_code="${codes[-1]:-0}"
    
    if [[ $success -gt 0 ]]; then
        reachable="true"
        packet_loss=$(awk "BEGIN {printf \"%.0f\", 100 * $failed / $PROBE_COUNT}")
        
        IFS=$'\n' sorted=($(sort -n <<<"${latencies[*]}")); unset IFS
        min_ms="${sorted[0]}"
        max_ms="${sorted[-1]}"
        
        local sum=0
        for lat in "${latencies[@]}"; do
            sum=$((sum + lat))
        done
        avg_ms=$(awk "BEGIN {printf \"%.1f\", $sum / $success}")
    fi
    
    # Check expected code
    local error=""
    if [[ "$reachable" == "true" && "$last_code" != "$EXPECT_CODE" ]]; then
        error="unexpected code $last_code (expected $EXPECT_CODE)"
        reachable="false"
    fi
    
    echo "$reachable|$avg_ms|$min_ms|$max_ms|$packet_loss|$last_code|$error"
}

# Determine probe type and test
probe_target() {
    local target="$1"
    local result
    
    if [[ -n "$URL" ]] || [[ "$target" =~ ^https?:// ]]; then
        result=$(test_http "$target")
        echo "http|$target|$result"
    elif [[ -n "$PORT" ]]; then
        result=$(test_tcp "$target" "$PORT")
        echo "tcp|$target:$PORT|$result"
    else
        result=$(test_icmp "$target")
        echo "icmp|$target|$result"
    fi
}

output_result_human() {
    local probe_type="$1" target="$2" reachable="$3" avg_ms="$4"
    local min_ms="$5" max_ms="$6" packet_loss="$7" http_code="$8" error="$9"
    
    local status_icon="✗"
    [[ "$reachable" == "true" ]] && status_icon="✓"
    
    printf "%s %-30s" "$status_icon" "$target"
    
    if [[ "$reachable" == "true" ]]; then
        printf "type=%-4s  avg=%-7s ms  min=%-7s ms  max=%-7s ms  loss=%s%%" \
            "$probe_type" "$avg_ms" "$min_ms" "$max_ms" "$packet_loss"
        [[ -n "$http_code" && "$http_code" != "" ]] && printf "  HTTP %s" "$http_code"
    else
        printf "UNREACHABLE"
        [[ -n "$error" ]] && printf " (%s)" "$error"
    fi
    echo ""
}

output_all_human() {
    local results="$1"
    local total=0 reachable_count=0
    
    echo "╔══════════════════════════════════════════════════════════════╗"
    echo "║           Network Reachability Report                        ║"
    echo "╠══════════════════════════════════════════════════════════════╣"
    
    while IFS='|' read -r probe_type target reachable avg_ms min_ms max_ms packet_loss http_code error; do
        [[ -z "$target" ]] && continue
        ((total++)) || true
        [[ "$reachable" == "true" ]] && ((reachable_count++)) || true
        output_result_human "$probe_type" "$target" "$reachable" "$avg_ms" "$min_ms" "$max_ms" "$packet_loss" "$http_code" "$error"
    done <<< "$results"
    
    echo "╠══════════════════════════════════════════════════════════════╣"
    printf "║  Summary: %d/%d targets reachable                              ║\n" "$reachable_count" "$total"
    echo "╚══════════════════════════════════════════════════════════════╝"
    
    [[ $reachable_count -eq $total ]] && return 0 || return 1
}

output_json() {
    local results="$1"
    local first=true
    
    echo "["
    while IFS='|' read -r probe_type target reachable avg_ms min_ms max_ms packet_loss http_code error; do
        [[ -z "$target" ]] && continue
        
        if [[ "$first" == "true" ]]; then
            first=false
        else
            echo ","
        fi
        
        # Convert strings to proper types
        local avg_num=${avg_ms:-0} min_num=${min_ms:-0} max_num=${max_ms:-0}
        local loss_num=${packet_loss:-100}
        local code_val="null"
        [[ -n "$http_code" && "$http_code" != "" ]] && code_val="$http_code"
        local error_val="null"
        [[ -n "$error" ]] && error_val="\"$error\""
        
        cat <<EOF
  {
    "target": "$target",
    "type": "$probe_type",
    "reachable": $reachable,
    "latency_avg_ms": $avg_num,
    "latency_min_ms": $min_num,
    "latency_max_ms": $max_num,
    "packet_loss": $loss_num,
    "http_code": $code_val,
    "error": $error_val
  }
EOF
    done <<< "$results"
    echo ""
    echo "]"
}

output_tsv() {
    local results="$1"
    
    printf "target\ttype\treachable\tlatency_avg_ms\tlatency_min_ms\tlatency_max_ms\tpacket_loss\thttp_code\terror\n"
    
    while IFS='|' read -r probe_type target reachable avg_ms min_ms max_ms packet_loss http_code error; do
        [[ -z "$target" ]] && continue
        printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
            "$target" "$probe_type" "$reachable" "$avg_ms" "$min_ms" "$max_ms" "$packet_loss" "$http_code" "$error"
    done <<< "$results"
}

# Main execution
all_results=""
any_unreachable=false

for target in "${TARGETS[@]}"; do
    result=$(probe_target "$target")
    all_results+="$result"$'\n'
    
    # Check if unreachable
    if [[ "$result" == *"|false|"* ]]; then
        any_unreachable=true
    fi
done

case "$OUTPUT_MODE" in
    human)
        if [[ "$QUIET" != "true" ]]; then
            output_all_human "$all_results"
        else
            # Quiet mode: just show failures
            while IFS='|' read -r probe_type target reachable _ _ _ _ _ error; do
                [[ "$reachable" == "false" ]] && echo "FAIL: $target ${error:+($error)}" >&2
            done <<< "$all_results"
        fi
        ;;
    json)  output_json "$all_results" ;;
    tsv)   output_tsv "$all_results" ;;
esac

if [[ "$any_unreachable" == "true" ]]; then
    exit 1
fi
exit 0
