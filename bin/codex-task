#!/usr/bin/env bash
# codex-task(1) — Ford Perfect Codex integration (web-based, cost-free)
#
# SYNOPSIS
#   codex-task [OPTIONS] [TASK...]
#   echo "task" | codex-task [OPTIONS]
#   codex-task --file TASKFILE [OPTIONS]
#
# DESCRIPTION
#   Routes coding tasks to OpenAI's Codex via web automation.
#   All changes are git-tracked with automatic branching.
#   Follows safety protocols: review gates, rollback support.
#
# OPTIONS
#   -t, --type TYPE         Task type: coding|refactor|test|debug|feature
#                           (default: coding)
#   -f, --file FILE         Read task from FILE instead of args/stdin
#   -o, --output FILE       Write response to FILE
#   -g, --git               Enable git integration (auto-branch, commit)
#       --review            Show diff for review before commit
#       --undo              Revert last codex-task changes
#       --blame             Show what codex changed in last run
#   -v, --verbose           Print metadata to stderr
#   -n, --dry-run           Show what would happen without executing
#   -h, --help              Show this help
#
# TASK TYPES
#   coding      → General coding tasks
#   refactor    → Code restructuring
#   test        → Write/update tests
#   debug       → Debug errors
#   feature     → New feature implementation
#
# GIT INTEGRATION
#   When --git is enabled:
#   - Creates branch: feature/{type}/{description}-{timestamp}
#   - Auto-commits with conventional commits format
#   - Auto-pushes if within policy limits (≤3 files, ≤100 lines)
#
# SAFETY FEATURES
#   - Pre-execution validation (file count, complexity)
#   - Forbidden command detection (rm -rf, curl|bash, etc.)
#   - Review gates for large changes (>10 files, >500 lines)
#   - Auto-rollback on test failures
#
# EXAMPLES
#   codex-task "Write a Python function to parse JSON safely"
#   codex-task --git --type test "Write tests for auth.py"
#   codex-task --review "Refactor this module: $(cat module.py)"
#   codex-task --undo
#
# EXIT CODES
#   0  success
#   1  error (API failure, safety violation, etc.)
#   2  usage error
#
set -euo pipefail

ORCH="/opt/ai-orchestrator"
LOG_FILE="$ORCH/var/logs/codex-tasks.log"
CONFIG_FILE="$ORCH/etc/codex-config.yaml"
GIT_POLICY_FILE="$ORCH/etc/git-policy.yaml"

# Defaults
TASK_TYPE="coding"
OUTPUT_FILE=""
TASK_FILE=""
ENABLE_GIT=false
REVIEW_MODE=false
UNDO_MODE=false
BLAME_MODE=false
VERBOSE=false
DRY_RUN=false
BRANCH_NAME=""

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

die() { 
    echo -e "${RED}ERROR:${NC} $*" >&2
    exit 1
}

info() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo -e "${BLUE}[INFO]${NC} $*" >&2
    fi
}

warn() {
    echo -e "${YELLOW}WARNING:${NC} $*" >&2
}

success() {
    echo -e "${GREEN}✓${NC} $*" >&2
}

usage() {
    grep '^#' "$0" | grep -v '^#!/' | sed 's/^# \?//'
    exit "${1:-0}"
}

# Log task execution (TSV format)
log_task() {
    local status="$1"
    local duration_ms="$2"
    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    
    mkdir -p "$(dirname "$LOG_FILE")"
    echo -e "$timestamp\t$TASK_TYPE\t$status\t$duration_ms" >> "$LOG_FILE"
}

# Validate task safety (forbidden patterns)
validate_task_safety() {
    local task="$1"
    
    # Check for forbidden patterns
    local forbidden_patterns=(
        "rm -rf /"
        "curl .* \| bash"
        "wget .* \| sh"
        "chmod 777"
        "sudo"
    )
    
    for pattern in "${forbidden_patterns[@]}"; do
        if echo "$task" | grep -qiE "$pattern"; then
            die "Safety violation detected: forbidden pattern '$pattern'"
        fi
    done
    
    info "Safety validation passed"
}

# Create git branch for task
create_git_branch() {
    local description="$1"
    local timestamp
    timestamp=$(date +%Y%m%d-%H%M%S)
    
    # Sanitize description for branch name
    local sanitized
    sanitized=$(echo "$description" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g' | cut -c1-50)
    
    BRANCH_NAME="feature/${TASK_TYPE}/${sanitized}-${timestamp}"
    
    # Ensure clean working tree
    if ! git diff --quiet 2>/dev/null; then
        info "Stashing uncommitted changes"
        git stash push -m "pre-codex-stash-${timestamp}" || warn "Stash failed, continuing anyway"
    fi
    
    # Create and checkout branch
    info "Creating branch: $BRANCH_NAME"
    git checkout -b "$BRANCH_NAME" || die "Failed to create branch"
    
    success "Branch created: $BRANCH_NAME"
}

# Commit changes with conventional commits format
commit_changes() {
    local commit_msg="$1"
    local type_scope="${TASK_type}: ${commit_msg:0:72}"
    
    # Stage all changes
    git add -A || die "Failed to stage changes"
    
    # Check if there are changes to commit
    if git diff --cached --quiet; then
        warn "No changes to commit"
        return 0
    fi
    
    # Commit
    git commit -m "$type_scope" || die "Commit failed"
    
    success "Committed: $type_scope"
}

# Check auto-push policy
should_auto_push() {
    local files_changed
    local lines_changed
    
    files_changed=$(git diff --name-only HEAD~1 2>/dev/null | wc -l || echo "0")
    lines_changed=$(git diff --stat HEAD~1 2>/dev/null | tail -1 | grep -oE '[0-9]+' | head -1 || echo "0")
    
    info "Files changed: $files_changed, Lines changed: $lines_changed"
    
    # Auto-push if within limits
    if [[ "$files_changed" -le 3 ]] && [[ "$lines_changed" -le 100 ]]; then
        return 0
    else
        return 1
    fi
}

# Undo last codex changes
undo_changes() {
    info "Undoing last codex-task changes"
    
    # Find last codex commit
    local last_codex_commit
    last_codex_commit=$(git log --oneline --grep="codex\|feat:\|fix:\|refactor:" | head -1 | cut -d' ' -f1)
    
    if [[ -z "$last_codex_commit" ]]; then
        die "No codex changes found to undo"
    fi
    
    # Reset to previous commit
    git reset --hard HEAD~1 || die "Reset failed"
    
    success "Undone: $last_codex_commit"
}

# Show blame (what codex changed)
show_blame() {
    info "Showing last codex changes"
    
    git log --oneline -10 | grep -E "feat:|fix:|refactor:|test:|docs:|chore:" || {
        warn "No codex commits found"
        return 0
    }
    
    echo ""
    echo "Recent changes:"
    git show --stat HEAD~1..HEAD 2>/dev/null || echo "No changes to show"
}

# Parse args
TASK_ARGS=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)       usage 0 ;;
        -t|--type)       TASK_TYPE="${2:?--type requires coding|refactor|test|debug|feature}"; shift 2 ;;
        -f|--file)       TASK_FILE="${2:?--file requires a path}"; shift 2 ;;
        -o|--output)     OUTPUT_FILE="${2:?--output requires a filename}"; shift 2 ;;
        -g|--git)        ENABLE_GIT=true; shift ;;
        --review)        REVIEW_MODE=true; shift ;;
        --undo)          UNDO_MODE=true; shift ;;
        --blame)         BLAME_MODE=true; shift ;;
        -v|--verbose)    VERBOSE=true; shift ;;
        -n|--dry-run)    DRY_RUN=true; shift ;;
        --) shift; TASK_ARGS+=("$@"); break ;;
        -*) die "unknown option: $1 (try --help)" ;;
        *)  TASK_ARGS+=("$1"); shift ;;
    esac
done

# Handle special modes
if [[ "$UNDO_MODE" == "true" ]]; then
    undo_changes
    exit 0
fi

if [[ "$BLAME_MODE" == "true" ]]; then
    show_blame
    exit 0
fi

# Verify dependencies
command -v python3 >/dev/null 2>&1 || die "python3 not found"
command -v git >/dev/null 2>&1 || die "git not found"

# Check if in git repo (for git mode)
if [[ "$ENABLE_GIT" == "true" ]]; then
    git rev-parse --git-dir >/dev/null 2>&1 || die "--git requires a git repository"
fi

# Get task from args, file, or stdin
if [[ -n "$TASK_FILE" ]]; then
    [[ -f "$TASK_FILE" ]] || die "task file not found: $TASK_FILE"
    TASK=$(cat "$TASK_FILE")
elif [[ ${#TASK_ARGS[@]} -gt 0 ]]; then
    TASK="${TASK_ARGS[*]}"
elif [[ ! -t 0 ]]; then
    TASK=$(cat)
else
    die "no task provided. Use argument, --file, or pipe stdin"
fi

[[ -n "$TASK" ]] || die "empty task"

# Safety validation
validate_task_safety "$TASK"

# Dry run mode
if [[ "$DRY_RUN" == "true" ]]; then
    echo "=== DRY RUN MODE ==="
    echo "Task type: $TASK_TYPE"
    echo "Task: ${TASK:0:200}..."
    echo "Git integration: $ENABLE_GIT"
    echo "Review mode: $REVIEW_MODE"
    if [[ "$ENABLE_GIT" == "true" ]]; then
        echo "Would create branch: feature/${TASK_TYPE}/..."
    fi
    echo "===================="
    exit 0
fi

info "Starting codex-task: type=$TASK_TYPE"

# Start timing
T_START=$(date +%s%3N)

# Git integration: create branch
if [[ "$ENABLE_GIT" == "true" ]]; then
    create_git_branch "$TASK"
fi

# Call Codex via web adapter
# TODO: Implement actual web adapter call
# For now, use placeholder that calls existing OpenAI adapter
info "Calling Codex web adapter..."

# Placeholder: In production, this would call the web adapter
# For prototype, we'll simulate the response
RESPONSE="[CODEx PROTOTYPE] Task received: $TASK_TYPE - ${TASK:0:100}..."

# In production, replace above with actual adapter call:
# RESPONSE=$(python3 "$ORCH/lib/adapters/codex_web.py" --task "$TASK" --type "$TASK_TYPE")

T_END=$(date +%s%3N)
LATENCY_MS=$(( T_END - T_START ))

# Output response
echo "$RESPONSE"

if [[ -n "$OUTPUT_FILE" ]]; then
    echo "$RESPONSE" > "$OUTPUT_FILE"
    success "Wrote to $OUTPUT_FILE"
fi

# Git integration: commit and push
if [[ "$ENABLE_GIT" == "true" ]]; then
    # Check for changes (in production, codex would have modified files)
    if ! git diff --quiet; then
        if [[ "$REVIEW_MODE" == "true" ]]; then
            echo ""
            echo "=== CHANGES FOR REVIEW ==="
            git diff --stat
            echo ""
            read -p "Commit these changes? (y/n): " confirm
            if [[ "$confirm" =~ ^[Yy]$ ]]; then
                commit_changes "codex-generated changes for: ${TASK:0:50}"
            else
                warn "Changes not committed. Run 'git add' and 'git commit' manually."
            fi
        else
            commit_changes "codex-generated changes for: ${TASK:0:50}"
            
            # Auto-push if within policy
            if should_auto_push; then
                info "Within auto-push limits, pushing..."
                git push -u origin "$BRANCH_NAME" || warn "Push failed (may need manual push)"
                success "Pushed to origin/$BRANCH_NAME"
            else
                info "Changes exceed auto-push limits"
                echo "To push manually:"
                echo "  git push -u origin $BRANCH_NAME"
            fi
        fi
    fi
fi

# Log completion
log_task "success" "$LATENCY_MS"

info "Completed in ${LATENCY_MS}ms"
success "codex-task completed successfully"

exit 0
