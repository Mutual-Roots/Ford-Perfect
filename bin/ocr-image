#!/usr/bin/env python3
"""
OCR Image â€” Extract text from images using Qwen-VL

Usage:
    ocr-image <image_path> [options]
    cat image.png | ocr-image --stdin
    ocr-image /path/to/dir/ --batch

Options:
    --lang <code>     Language hint (auto, en, de, zh, etc.)
    --model <name>    Qwen-VL model (default: qwen3-vl-flash)
    --json            Output as JSON instead of plain text
    --batch           Process all images in directory
    --stdin           Read image from stdin (base64)

Supported formats: PNG, JPG, JPEG, WebP, GIF, BMP
Max size: 20MB per image

Examples:
    ocr-image screenshot.png
    ocr-image document.jpg --lang de --json
    ocr-image ./screenshots/ --batch --json > results.json
"""

import sys
import os
import json
import base64
import urllib.request
import urllib.error
from pathlib import Path
from typing import Union, List

# Add lib to path
sys.path.insert(0, '/opt/ai-orchestrator/lib')

DASHSCOPE_KEY = os.environ.get("DASHSCOPE_INTL_API_KEY", "")
VL_BASE = "https://dashscope-intl.aliyuncs.com/compatible-mode/v1/chat/completions"
DEFAULT_MODEL = "qwen3-vl-flash"


def encode_image(image_path: Union[str, Path]) -> str:
    """Encode image to base64 data URL."""
    path = Path(image_path)
    if not path.exists():
        raise FileNotFoundError(f"Image not found: {image_path}")
    
    ext = path.suffix.lower()
    mime_map = {
        '.png': 'image/png', '.jpg': 'image/jpeg', '.jpeg': 'image/jpeg',
        '.webp': 'image/webp', '.gif': 'image/gif', '.bmp': 'image/bmp',
    }
    mime_type = mime_map.get(ext, 'image/png')
    
    with open(path, 'rb') as f:
        data = base64.b64encode(f.read()).decode('utf-8')
    
    return f"data:{mime_type};base64,{data}"


def ocr_image(
    image_input: Union[str, Path, bytes],
    language: str = "auto",
    model: str = DEFAULT_MODEL,
    from_stdin: bool = False,
) -> dict:
    """
    Extract text from image.
    
    Args:
        image_input: File path, or bytes if from_stdin
        language: Language hint
        model: Qwen-VL model
        from_stdin: If True, image_input is raw bytes
    
    Returns:
        Dict with text, usage, latency_ms
    """
    if not DASHSCOPE_KEY:
        raise EnvironmentError("DASHSCOPE_INTL_API_KEY not set")
    
    # Prepare image content
    if from_stdin:
        data_url = f"data:image/png;base64,{base64.b64encode(image_input).decode('utf-8')}"
    elif isinstance(image_input, (str, Path)) and Path(image_input).exists():
        data_url = encode_image(image_input)
    elif isinstance(image_input, str) and image_input.startswith("http"):
        data_url = image_input
    else:
        raise ValueError(f"Invalid image input: {image_input}")
    
    # Build prompt
    lang_instr = f"Language: {language}. " if language != "auto" else ""
    prompt = (
        f"{lang_instr}Extract ALL text verbatim. Preserve formatting. "
        f"Output ONLY extracted text, no commentary."
    )
    
    # Prepare request
    payload = {
        "model": model,
        "messages": [
            {
                "role": "system",
                "content": "You are an OCR engine. Extract text accurately."
            },
            {
                "role": "user",
                "content": [
                    {"type": "image_url", "image_url": {"url": data_url}},
                    {"type": "text", "text": prompt}
                ]
            }
        ],
        "max_tokens": 4000
    }
    
    # Make request
    req = urllib.request.Request(
        VL_BASE,
        data=json.dumps(payload).encode('utf-8'),
        headers={
            "Authorization": f"Bearer {DASHSCOPE_KEY}",
            "Content-Type": "application/json"
        }
    )
    
    import time
    t0 = time.time()
    
    try:
        with urllib.request.urlopen(req, timeout=60) as resp:
            response_data = json.loads(resp.read().decode('utf-8'))
        
        latency_ms = int((time.time() - t0) * 1000)
        text = response_data.get("choices", [{}])[0].get("message", {}).get("content", "")
        usage = response_data.get("usage", {})
        
        return {
            "text": text.strip(),
            "model": response_data.get("model", model),
            "usage": usage,
            "latency_ms": latency_ms,
            "source": str(image_input) if not from_stdin else "stdin"
        }
        
    except urllib.error.HTTPError as e:
        error_body = e.read().decode('utf-8') if e.fp else ""
        raise RuntimeError(f"API error {e.code}: {error_body[:500]}")


def find_images(directory: Union[str, Path]) -> List[Path]:
    """Find all image files in directory."""
    dir_path = Path(directory)
    if not dir_path.is_dir():
        raise NotADirectoryError(f"Not a directory: {directory}")
    
    extensions = {'.png', '.jpg', '.jpeg', '.webp', '.gif', '.bmp'}
    images = []
    
    for ext in extensions:
        images.extend(dir_path.glob(f"*{ext}"))
        images.extend(dir_path.glob(f"*{ext.upper()}"))
    
    return sorted(images)


def main():
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Extract text from images using Qwen-VL OCR",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    
    parser.add_argument("input", nargs="?", help="Image file path or directory (with --batch)")
    parser.add_argument("--lang", default="auto", help="Language hint (default: auto)")
    parser.add_argument("--model", default=DEFAULT_MODEL, help=f"Model (default: {DEFAULT_MODEL})")
    parser.add_argument("--json", action="store_true", help="Output as JSON")
    parser.add_argument("--batch", action="store_true", help="Process directory of images")
    parser.add_argument("--stdin", action="store_true", help="Read image from stdin")
    
    args = parser.parse_args()
    
    # Validate inputs
    if args.stdin:
        if args.input:
            print("Warning: --stdin ignores positional argument", file=sys.stderr)
        image_data = sys.stdin.buffer.read()
        if not image_data:
            print("Error: No data received on stdin", file=sys.stderr)
            sys.exit(1)
        
        try:
            result = ocr_image(image_data, language=args.lang, model=args.model, from_stdin=True)
        except Exception as e:
            print(f"Error: {e}", file=sys.stderr)
            sys.exit(1)
        
        if args.json:
            print(json.dumps(result, ensure_ascii=False, indent=2))
        else:
            print(result["text"])
        
        return
    
    if not args.input:
        print("Error: Missing image path. Use --stdin for stdin input.", file=sys.stderr)
        sys.exit(1)
    
    input_path = Path(args.input)
    
    if args.batch:
        # Batch mode: process directory
        if not input_path.is_dir():
            print(f"Error: {args.input} is not a directory", file=sys.stderr)
            sys.exit(1)
        
        images = find_images(input_path)
        if not images:
            print(f"No images found in {args.input}", file=sys.stderr)
            sys.exit(1)
        
        results = []
        for i, img_path in enumerate(images, 1):
            print(f"[{i}/{len(images)}] Processing: {img_path.name}", file=sys.stderr)
            try:
                result = ocr_image(img_path, language=args.lang, model=args.model)
                results.append(result)
                
                if not args.json:
                    print(f"\n--- {img_path.name} ---", file=sys.stderr)
                    print(result["text"])
                    
            except Exception as e:
                error_result = {
                    "source": str(img_path),
                    "error": str(e)
                }
                results.append(error_result)
                print(f"Error: {e}", file=sys.stderr)
        
        if args.json:
            print(json.dumps(results, ensure_ascii=False, indent=2))
    
    else:
        # Single image mode
        if not input_path.exists():
            print(f"Error: File not found: {args.input}", file=sys.stderr)
            sys.exit(1)
        
        try:
            result = ocr_image(input_path, language=args.lang, model=args.model)
        except Exception as e:
            print(f"Error: {e}", file=sys.stderr)
            sys.exit(1)
        
        if args.json:
            print(json.dumps(result, ensure_ascii=False, indent=2))
        else:
            print(result["text"])


if __name__ == "__main__":
    main()
